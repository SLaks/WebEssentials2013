using System;
using System.IO;
using Microsoft.VisualStudio.Text;

namespace MadsKristensen.EditorExtensions.Compilers
{
    ///<summary>An <see cref="ICompilationNotifier"/> that watches for TypeScript files generated by VS' built-in async compiler.</summary>
    internal class TypeScriptCompilationNotifier : ICompilationNotifier
    {
        private readonly FileSystemWatcher _watcher;
        public ITextDocument Document { get; private set; }
        public string SourceFilePath { get { return Document.FilePath; } }
        public string TargetFilePath { get { return Path.ChangeExtension(SourceFilePath, ".js"); } }

        private bool _isReady;

        public TypeScriptCompilationNotifier(ITextDocument doc)
        {
            Document = doc;
            Document.FileActionOccurred += Document_FileActionOccurred;

            _watcher = new FileSystemWatcher(Path.GetDirectoryName(TargetFilePath)) {
                Filter = Path.GetFileName(TargetFilePath)
            };
            _watcher.EnableRaisingEvents = true;
            _watcher.Created += FileTouched;
            _watcher.Changed += FileTouched;
        }

        private void Document_FileActionOccurred(object sender, TextDocumentFileActionEventArgs e)
        {
            if (e.FileActionType != FileActionTypes.DocumentRenamed)
                return;
            _watcher.Path = Path.GetDirectoryName(TargetFilePath);
            _watcher.Filter = Path.GetFileName(TargetFilePath);
        }


        ///<summary>Releases all resources used by the EditorCompilerInvoker.</summary>
        public void Dispose() { Dispose(true); GC.SuppressFinalize(this); }
        ///<summary>Releases the unmanaged resources used by the EditorCompilerInvoker and optionally releases the managed resources.</summary>
        ///<param name="disposing">true to release both managed and unmanaged resources; false to release only unmanaged resources.</param>
        protected virtual void Dispose(bool disposing)
        {
            if (disposing)
            {
                Document.FileActionOccurred -= Document_FileActionOccurred;
                _watcher.Created -= FileTouched;
                _watcher.Changed -= FileTouched;
                _watcher.Dispose();
            }
        }

        ///<summary>Occurs when the file has been compiled (on both success and failure).</summary>
        public event EventHandler<CompilerResultEventArgs> CompilationReady;
        ///<summary>Raises the CompilationReady event.</summary>
        ///<param name="e">A CompilerResultEventArgs object that provides the event data.</param>
        protected virtual void OnCompilationReady(CompilerResultEventArgs e)
        {
            if (CompilationReady != null)
                CompilationReady(this, e);
        }

        private void FileTouched(object sender, FileSystemEventArgs e)
        {
            // The check for _isReady is in place to deal with the issue where
            // FileSystemWatcher fires twice per file change.
            if (!_isReady)
            {
                _isReady = true;
                return;
            }

            if (File.Exists(TargetFilePath))
                RaiseReady();
            _isReady = false;
        }

        public void RequestCompilationResult(bool cached)
        {
            if (File.Exists(TargetFilePath))
                RaiseReady();
            else
                OnCompilationReady(new CompilerResultEventArgs(new CompilerResult(SourceFilePath, null) {
                    IsSuccess = true,   // HACK: Set IsSuccess to true to force margin to display result
                    Result = "// Not compiled to disk yet"
                }));
        }

        private void RaiseReady()
        {
            OnCompilationReady(new CompilerResultEventArgs(new CompilerResult(SourceFilePath, TargetFilePath) {
                IsSuccess = true,
                Result = File.ReadAllText(TargetFilePath)
            }));
        }
    }
}