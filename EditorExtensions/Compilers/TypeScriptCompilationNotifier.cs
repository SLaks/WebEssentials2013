using System;
using System.IO;
using Microsoft.VisualStudio.Text;

namespace MadsKristensen.EditorExtensions.Compilers
{
    ///<summary>An <see cref="ICompilationNotifier"/> that watches for TypeScript files generated by VS' built-in async compiler.</summary>
    internal class TypeScriptCompilationNotifier : ICompilationNotifier
    {
        private readonly FileSystemWatcher _watcher;
        public string SourceFilePath { get; private set; }
        public string TargetFilePath { get; private set; }

        private bool _isReady;

        public TypeScriptCompilationNotifier(string sourcePath)
        {
            SourceFilePath = sourcePath;
            TargetFilePath = Path.ChangeExtension(sourcePath, ".js");

            _watcher = new FileSystemWatcher(Path.GetDirectoryName(TargetFilePath)) {
                Filter = Path.GetFileName(TargetFilePath)
            };
            _watcher.EnableRaisingEvents = true;
            _watcher.Created += FileTouched;
            _watcher.Changed += FileTouched;
        }

        ///<summary>Releases all resources used by the EditorCompilerInvoker.</summary>
        public void Dispose() { Dispose(true); GC.SuppressFinalize(this); }
        ///<summary>Releases the unmanaged resources used by the EditorCompilerInvoker and optionally releases the managed resources.</summary>
        ///<param name="disposing">true to release both managed and unmanaged resources; false to release only unmanaged resources.</param>
        protected virtual void Dispose(bool disposing)
        {
            if (disposing)
            {
                _watcher.Created -= FileTouched;
                _watcher.Changed -= FileTouched;
                _watcher.Dispose();
            }
        }

        ///<summary>Occurs when the file has been compiled (on both success and failure).</summary>
        public event EventHandler<CompilerResultEventArgs> CompilationReady;
        ///<summary>Raises the CompilationReady event.</summary>
        ///<param name="e">A CompilerResultEventArgs object that provides the event data.</param>
        protected virtual void OnCompilationReady(CompilerResultEventArgs e)
        {
            if (CompilationReady != null)
                CompilationReady(this, e);
        }

        private void FileTouched(object sender, FileSystemEventArgs e)
        {
            // The check for _isReady is in place to deal with the issue where
            // FileSystemWatcher fires twice per file change.
            if (!_isReady)
            {
                _isReady = true;
                return;
            }

            if (File.Exists(TargetFilePath))
                RaiseReady();
            _isReady = false;
        }

        public void RequestCompilationResult(bool cached)
        {
            if (File.Exists(TargetFilePath))
                RaiseReady();
            else
                OnCompilationReady(new CompilerResultEventArgs(new CompilerResult(SourceFilePath, null) {
                    IsSuccess = true,   // HACK: Set IsSuccess to true to force margin to display result
                    Result = "// Not compiled to disk yet"
                }));
        }

        private void RaiseReady()
        {
            OnCompilationReady(new CompilerResultEventArgs(new CompilerResult(SourceFilePath, TargetFilePath) {
                IsSuccess = true,
                Result = File.ReadAllText(TargetFilePath)
            }));
        }
    }
}